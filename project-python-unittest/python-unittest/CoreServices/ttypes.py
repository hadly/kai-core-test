#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException
import EventStructures.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class CoreException(TException):
  """
  CoreException
  (1) errorCode - Error code indicating the type of error
  (2) description - Human readable description of what is the error

  Attributes:
   - errorCode
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'description', None, None, ), # 2
  )

  def __init__(self, errorCode=None, description=None,):
    self.errorCode = errorCode
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.errorCode = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CoreException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I64, 1)
      oprot.writeI64(self.errorCode)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 2)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamClientInfo:
  """
  Stream Client Info
  (1) clientIp - IP address of the client connected to this stream
  (2) clientPort - Port number of the client connected to this stream

  Attributes:
   - clientIp
   - clientPort
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientIp', None, None, ), # 1
    (2, TType.STRING, 'clientPort', None, None, ), # 2
  )

  def __init__(self, clientIp=None, clientPort=None,):
    self.clientIp = clientIp
    self.clientPort = clientPort

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientIp = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientPort = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamClientInfo')
    if self.clientIp is not None:
      oprot.writeFieldBegin('clientIp', TType.STRING, 1)
      oprot.writeString(self.clientIp)
      oprot.writeFieldEnd()
    if self.clientPort is not None:
      oprot.writeFieldBegin('clientPort', TType.STRING, 2)
      oprot.writeString(self.clientPort)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamInfo:
  """
  Stream Information
  (1) deviceId - The device ID
  (2) channelId - The channel ID
  (3) isLiveview - Indicates liveview or playback
  (4) type - The stream type, e.g. "http/jpeg" or "rtmp/h264"
  (5) url - The stream URL as visible to outside world
  (6) startTime - The timestamp when stream was started (ddMMyyyyHHmmss format)
  (7) clients - List of clients connected to this stream

  Attributes:
   - deviceId
   - channelId
   - isLiveview
   - type
   - url
   - startTime
   - clients
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.BOOL, 'isLiveview', None, None, ), # 3
    (4, TType.STRING, 'type', None, None, ), # 4
    (5, TType.STRING, 'url', None, None, ), # 5
    (6, TType.STRING, 'startTime', None, None, ), # 6
    (7, TType.LIST, 'clients', (TType.STRUCT,(StreamClientInfo, StreamClientInfo.thrift_spec)), None, ), # 7
  )

  def __init__(self, deviceId=None, channelId=None, isLiveview=None, type=None, url=None, startTime=None, clients=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.isLiveview = isLiveview
    self.type = type
    self.url = url
    self.startTime = startTime
    self.clients = clients

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isLiveview = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.startTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.clients = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = StreamClientInfo()
            _elem5.read(iprot)
            self.clients.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamInfo')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.isLiveview is not None:
      oprot.writeFieldBegin('isLiveview', TType.BOOL, 3)
      oprot.writeBool(self.isLiveview)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 4)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 5)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.STRING, 6)
      oprot.writeString(self.startTime)
      oprot.writeFieldEnd()
    if self.clients is not None:
      oprot.writeFieldBegin('clients', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.clients))
      for iter6 in self.clients:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RecordedVideoInfo:
  """
  Recorded Video Information
  (1) deviceId - The device ID
  (2) channelId - The channel ID
  (3) timeFrom - The timestamp when video was started (ddMMyyyyHHmmss format)
  (4) timeTo - The timestamp when video was stoped (ddMMyyyyHHmmss format)

  Attributes:
   - deviceId
   - channelId
   - timeFrom
   - timeTo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.STRING, 'timeFrom', None, None, ), # 3
    (4, TType.STRING, 'timeTo', None, None, ), # 4
  )

  def __init__(self, deviceId=None, channelId=None, timeFrom=None, timeTo=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.timeFrom = timeFrom
    self.timeTo = timeTo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timeFrom = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timeTo = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RecordedVideoInfo')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.timeFrom is not None:
      oprot.writeFieldBegin('timeFrom', TType.STRING, 3)
      oprot.writeString(self.timeFrom)
      oprot.writeFieldEnd()
    if self.timeTo is not None:
      oprot.writeFieldBegin('timeTo', TType.STRING, 4)
      oprot.writeString(self.timeTo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageInfo:
  """
  Recording Server Storage Status
  (1) serverId - The recording server ID
  (2) serverHost - The recording server host
  (3) streamCount - The number of streams that server is processing
  (4) freeSpace - The available disk space in this server. uint: MB
  (5) totalSpace - The total disk space in this server. uint: MB

  Attributes:
   - serverId
   - serverHost
   - streamCount
   - freeSpace
   - totalSpace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serverId', None, None, ), # 1
    (2, TType.STRING, 'serverHost', None, None, ), # 2
    (3, TType.I64, 'streamCount', None, None, ), # 3
    (4, TType.I64, 'freeSpace', None, None, ), # 4
    (5, TType.I64, 'totalSpace', None, None, ), # 5
  )

  def __init__(self, serverId=None, serverHost=None, streamCount=None, freeSpace=None, totalSpace=None,):
    self.serverId = serverId
    self.serverHost = serverHost
    self.streamCount = streamCount
    self.freeSpace = freeSpace
    self.totalSpace = totalSpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serverId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serverHost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.streamCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.freeSpace = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.totalSpace = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageInfo')
    if self.serverId is not None:
      oprot.writeFieldBegin('serverId', TType.STRING, 1)
      oprot.writeString(self.serverId)
      oprot.writeFieldEnd()
    if self.serverHost is not None:
      oprot.writeFieldBegin('serverHost', TType.STRING, 2)
      oprot.writeString(self.serverHost)
      oprot.writeFieldEnd()
    if self.streamCount is not None:
      oprot.writeFieldBegin('streamCount', TType.I64, 3)
      oprot.writeI64(self.streamCount)
      oprot.writeFieldEnd()
    if self.freeSpace is not None:
      oprot.writeFieldBegin('freeSpace', TType.I64, 4)
      oprot.writeI64(self.freeSpace)
      oprot.writeFieldEnd()
    if self.totalSpace is not None:
      oprot.writeFieldBegin('totalSpace', TType.I64, 5)
      oprot.writeI64(self.totalSpace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LocationDataPoint:
  """
  Location Data
  (1) time - the timestamp in DDMMYYYYhhmmss format
  (2) latitude - the latitude
  (3) longitude - the longitude
  (4) direction - the current direction of movement, in degrees * 100
  (5) speed - the current speed, in km/h

  Attributes:
   - time
   - latitude
   - longitude
   - direction
   - speed
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'time', None, None, ), # 1
    (2, TType.DOUBLE, 'latitude', None, None, ), # 2
    (3, TType.DOUBLE, 'longitude', None, None, ), # 3
    (4, TType.I64, 'direction', None, None, ), # 4
    (5, TType.DOUBLE, 'speed', None, None, ), # 5
  )

  def __init__(self, time=None, latitude=None, longitude=None, direction=None, speed=None,):
    self.time = time
    self.latitude = latitude
    self.longitude = longitude
    self.direction = direction
    self.speed = speed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.time = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.latitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.longitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.direction = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.speed = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LocationDataPoint')
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.STRING, 1)
      oprot.writeString(self.time)
      oprot.writeFieldEnd()
    if self.latitude is not None:
      oprot.writeFieldBegin('latitude', TType.DOUBLE, 2)
      oprot.writeDouble(self.latitude)
      oprot.writeFieldEnd()
    if self.longitude is not None:
      oprot.writeFieldBegin('longitude', TType.DOUBLE, 3)
      oprot.writeDouble(self.longitude)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.I64, 4)
      oprot.writeI64(self.direction)
      oprot.writeFieldEnd()
    if self.speed is not None:
      oprot.writeFieldBegin('speed', TType.DOUBLE, 5)
      oprot.writeDouble(self.speed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GSensorDataPoint:
  """
  GSensor Data
  (1) time - the timestamp in DDMMYYYYhhmmss format
  (2) x - the G value in X direction
  (3) y - the G value in Y direction
  (4) z - the G value in Z direction

  Attributes:
   - time
   - x
   - y
   - z
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'time', None, None, ), # 1
    (2, TType.DOUBLE, 'x', None, None, ), # 2
    (3, TType.DOUBLE, 'y', None, None, ), # 3
    (4, TType.DOUBLE, 'z', None, None, ), # 4
  )

  def __init__(self, time=None, x=None, y=None, z=None,):
    self.time = time
    self.x = x
    self.y = y
    self.z = z

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.time = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.z = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GSensorDataPoint')
    if self.time is not None:
      oprot.writeFieldBegin('time', TType.STRING, 1)
      oprot.writeString(self.time)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 2)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 3)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    if self.z is not None:
      oprot.writeFieldBegin('z', TType.DOUBLE, 4)
      oprot.writeDouble(self.z)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceModel:
  """
  Device Model Structure - a structure of this type represents a model
  of devices in the system.

  Most of the fields in this API are mapped to corresponding fields in
  Core Engine's existing database. RMS+ can safely ignore the fields that
  it does not require.

  (1) id - Unique identifier of this model
  (2) createdAt - Not used
  (3) createdBy - Not used
  (4) modifiedAt - Not used
  (5) modifiedBy - Not used
  (6) name - Model name
  (7) channels - Number of channels that the devices of this model have
  (8) data - Not used
  (9) action - Not used
  (10) misc - JSON formatted additional miscellaneous information, e.g.
    {
      "servertype": "http-camera",
      "supportedtasktypes": ["live-image"],
      "device_url": "http://#{device:host}:#{device:misc:port}/",
      "onboard_recording_server": "http://#{device:host}:#{device:misc:port}/setup/recording.html"
    }
  (11) liveview - Boolean flag, TRUE if this device supports live view, FALSE otherwise.
    {
      "0": {
        "activex": {
          "objectcode": "<object.../object>",
          "ptz": {
            "left": "...",
            "right": "...",
            "up": "...",
            "down": "...",
            "in": "...",
            "out": "...",
            "home": "..."
          }
        },
        "mjpeg": {
          "objectcode": "<applet.../applet>"
        }
      }
    }

  Attributes:
   - id
   - createdAt
   - createdBy
   - modifiedAt
   - modifiedBy
   - name
   - channels
   - data
   - action
   - misc
   - liveview
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'createdAt', None, None, ), # 2
    (3, TType.STRING, 'createdBy', None, None, ), # 3
    (4, TType.STRING, 'modifiedAt', None, None, ), # 4
    (5, TType.STRING, 'modifiedBy', None, None, ), # 5
    (6, TType.STRING, 'name', None, None, ), # 6
    (7, TType.STRING, 'channels', None, None, ), # 7
    (8, TType.STRING, 'data', None, None, ), # 8
    (9, TType.STRING, 'action', None, None, ), # 9
    (10, TType.STRING, 'misc', None, None, ), # 10
    (11, TType.STRING, 'liveview', None, None, ), # 11
  )

  def __init__(self, id=None, createdAt=None, createdBy=None, modifiedAt=None, modifiedBy=None, name=None, channels=None, data=None, action=None, misc=None, liveview=None,):
    self.id = id
    self.createdAt = createdAt
    self.createdBy = createdBy
    self.modifiedAt = modifiedAt
    self.modifiedBy = modifiedBy
    self.name = name
    self.channels = channels
    self.data = data
    self.action = action
    self.misc = misc
    self.liveview = liveview

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.createdAt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.createdBy = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.modifiedAt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.modifiedBy = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.channels = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.misc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.liveview = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceModel')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.createdAt is not None:
      oprot.writeFieldBegin('createdAt', TType.STRING, 2)
      oprot.writeString(self.createdAt)
      oprot.writeFieldEnd()
    if self.createdBy is not None:
      oprot.writeFieldBegin('createdBy', TType.STRING, 3)
      oprot.writeString(self.createdBy)
      oprot.writeFieldEnd()
    if self.modifiedAt is not None:
      oprot.writeFieldBegin('modifiedAt', TType.STRING, 4)
      oprot.writeString(self.modifiedAt)
      oprot.writeFieldEnd()
    if self.modifiedBy is not None:
      oprot.writeFieldBegin('modifiedBy', TType.STRING, 5)
      oprot.writeString(self.modifiedBy)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 6)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.channels is not None:
      oprot.writeFieldBegin('channels', TType.STRING, 7)
      oprot.writeString(self.channels)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 8)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRING, 9)
      oprot.writeString(self.action)
      oprot.writeFieldEnd()
    if self.misc is not None:
      oprot.writeFieldBegin('misc', TType.STRING, 10)
      oprot.writeString(self.misc)
      oprot.writeFieldEnd()
    if self.liveview is not None:
      oprot.writeFieldBegin('liveview', TType.STRING, 11)
      oprot.writeString(self.liveview)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeviceDetails:
  """
  Detailed Device Information
  Most of the fields in this API are mapped to corresponding fields in
  Core Engine's existing database. RMS+ can safely ignore the fields that
  it does not require.

  (1) id - Unique identifier of this device
  (2) name - Device Name
  (3) key - MAC address of the device in the common notational format, e.g. 01:23:45:67:89:ab
  (4) host - Device IP address or hostname
  (5) port - Device port.
  (6) login - Device login (user name). Ignore if not required.
  (7) password - Device password. Ignore if not required.
  (8) address - The default physical address of the location where the device is installed (postal address).
  (9) lat - The default Latitude
  (10) lng - The default Longitude
  (11) accountId - ID of account this device is associated with.
  (12) modelId - Model of this device
  (13) statusId - "pending" or "active". Default status is "pending" until
                 it is activated by the activateDevice() function.
  (14) functionalityId - Not used
  (15) alertFlag - Not used
  (16) alive - Not used
  (17) currentPositionId - Not used
  (18) action - Not used
  (19) eventSettings - Not used
  (20) deviceServerUrls - Not used
  (21) liveview - Not used
  (22) snapshotRecordingEnabled - "true" to enable snapshot recording, "false" to disable
  (23) snapshotRecordingInterval - Save the snapshot for this device every "snapshotRecordingInterval" seconds. Unit is "second".
  (24) cloudRecordingEnabled - "true" to enable recording of device in cloud, "false" to disable

  Attributes:
   - id
   - name
   - key
   - host
   - port
   - login
   - password
   - address
   - lat
   - lng
   - accountId
   - modelId
   - statusId
   - functionalityId
   - alertFlag
   - alive
   - currentPositionId
   - action
   - eventSettings
   - deviceServerUrls
   - liveview
   - snapshotRecordingEnabled
   - snapshotRecordingInterval
   - cloudRecordingEnabled
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
    (4, TType.STRING, 'host', None, None, ), # 4
    (5, TType.STRING, 'port', None, None, ), # 5
    (6, TType.STRING, 'login', None, None, ), # 6
    (7, TType.STRING, 'password', None, None, ), # 7
    (8, TType.STRING, 'address', None, None, ), # 8
    (9, TType.STRING, 'lat', None, None, ), # 9
    (10, TType.STRING, 'lng', None, None, ), # 10
    (11, TType.STRING, 'accountId', None, None, ), # 11
    (12, TType.STRING, 'modelId', None, None, ), # 12
    (13, TType.STRING, 'statusId', None, None, ), # 13
    (14, TType.STRING, 'functionalityId', None, None, ), # 14
    (15, TType.STRING, 'alertFlag', None, None, ), # 15
    (16, TType.STRING, 'alive', None, None, ), # 16
    (17, TType.STRING, 'currentPositionId', None, None, ), # 17
    (18, TType.STRING, 'action', None, None, ), # 18
    (19, TType.STRING, 'eventSettings', None, None, ), # 19
    (20, TType.STRING, 'deviceServerUrls', None, None, ), # 20
    (21, TType.STRING, 'liveview', None, None, ), # 21
    (22, TType.STRING, 'snapshotRecordingEnabled', None, None, ), # 22
    (23, TType.STRING, 'snapshotRecordingInterval', None, None, ), # 23
    (24, TType.STRING, 'cloudRecordingEnabled', None, None, ), # 24
  )

  def __init__(self, id=None, name=None, key=None, host=None, port=None, login=None, password=None, address=None, lat=None, lng=None, accountId=None, modelId=None, statusId=None, functionalityId=None, alertFlag=None, alive=None, currentPositionId=None, action=None, eventSettings=None, deviceServerUrls=None, liveview=None, snapshotRecordingEnabled=None, snapshotRecordingInterval=None, cloudRecordingEnabled=None,):
    self.id = id
    self.name = name
    self.key = key
    self.host = host
    self.port = port
    self.login = login
    self.password = password
    self.address = address
    self.lat = lat
    self.lng = lng
    self.accountId = accountId
    self.modelId = modelId
    self.statusId = statusId
    self.functionalityId = functionalityId
    self.alertFlag = alertFlag
    self.alive = alive
    self.currentPositionId = currentPositionId
    self.action = action
    self.eventSettings = eventSettings
    self.deviceServerUrls = deviceServerUrls
    self.liveview = liveview
    self.snapshotRecordingEnabled = snapshotRecordingEnabled
    self.snapshotRecordingInterval = snapshotRecordingInterval
    self.cloudRecordingEnabled = cloudRecordingEnabled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.host = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.port = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.login = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.address = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.lat = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.lng = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.accountId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.modelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.statusId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.functionalityId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.alertFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.alive = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.currentPositionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.eventSettings = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.deviceServerUrls = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.liveview = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.snapshotRecordingEnabled = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.snapshotRecordingInterval = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.cloudRecordingEnabled = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceDetails')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 4)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.STRING, 5)
      oprot.writeString(self.port)
      oprot.writeFieldEnd()
    if self.login is not None:
      oprot.writeFieldBegin('login', TType.STRING, 6)
      oprot.writeString(self.login)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 7)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.address is not None:
      oprot.writeFieldBegin('address', TType.STRING, 8)
      oprot.writeString(self.address)
      oprot.writeFieldEnd()
    if self.lat is not None:
      oprot.writeFieldBegin('lat', TType.STRING, 9)
      oprot.writeString(self.lat)
      oprot.writeFieldEnd()
    if self.lng is not None:
      oprot.writeFieldBegin('lng', TType.STRING, 10)
      oprot.writeString(self.lng)
      oprot.writeFieldEnd()
    if self.accountId is not None:
      oprot.writeFieldBegin('accountId', TType.STRING, 11)
      oprot.writeString(self.accountId)
      oprot.writeFieldEnd()
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.STRING, 12)
      oprot.writeString(self.modelId)
      oprot.writeFieldEnd()
    if self.statusId is not None:
      oprot.writeFieldBegin('statusId', TType.STRING, 13)
      oprot.writeString(self.statusId)
      oprot.writeFieldEnd()
    if self.functionalityId is not None:
      oprot.writeFieldBegin('functionalityId', TType.STRING, 14)
      oprot.writeString(self.functionalityId)
      oprot.writeFieldEnd()
    if self.alertFlag is not None:
      oprot.writeFieldBegin('alertFlag', TType.STRING, 15)
      oprot.writeString(self.alertFlag)
      oprot.writeFieldEnd()
    if self.alive is not None:
      oprot.writeFieldBegin('alive', TType.STRING, 16)
      oprot.writeString(self.alive)
      oprot.writeFieldEnd()
    if self.currentPositionId is not None:
      oprot.writeFieldBegin('currentPositionId', TType.STRING, 17)
      oprot.writeString(self.currentPositionId)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRING, 18)
      oprot.writeString(self.action)
      oprot.writeFieldEnd()
    if self.eventSettings is not None:
      oprot.writeFieldBegin('eventSettings', TType.STRING, 19)
      oprot.writeString(self.eventSettings)
      oprot.writeFieldEnd()
    if self.deviceServerUrls is not None:
      oprot.writeFieldBegin('deviceServerUrls', TType.STRING, 20)
      oprot.writeString(self.deviceServerUrls)
      oprot.writeFieldEnd()
    if self.liveview is not None:
      oprot.writeFieldBegin('liveview', TType.STRING, 21)
      oprot.writeString(self.liveview)
      oprot.writeFieldEnd()
    if self.snapshotRecordingEnabled is not None:
      oprot.writeFieldBegin('snapshotRecordingEnabled', TType.STRING, 22)
      oprot.writeString(self.snapshotRecordingEnabled)
      oprot.writeFieldEnd()
    if self.snapshotRecordingInterval is not None:
      oprot.writeFieldBegin('snapshotRecordingInterval', TType.STRING, 23)
      oprot.writeString(self.snapshotRecordingInterval)
      oprot.writeFieldEnd()
    if self.cloudRecordingEnabled is not None:
      oprot.writeFieldBegin('cloudRecordingEnabled', TType.STRING, 24)
      oprot.writeString(self.cloudRecordingEnabled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TagInfo:
  """
  Tag information
  (1) tagId - ID of the tag
  (2) macAddress - MAC address of the tag in the common notational format, e.g. 01:23:45:67:89:ab

  Attributes:
   - tagId
   - macAddress
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tagId', None, None, ), # 1
    (2, TType.STRING, 'macAddress', None, None, ), # 2
  )

  def __init__(self, tagId=None, macAddress=None,):
    self.tagId = tagId
    self.macAddress = macAddress

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tagId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.macAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TagInfo')
    if self.tagId is not None:
      oprot.writeFieldBegin('tagId', TType.STRING, 1)
      oprot.writeString(self.tagId)
      oprot.writeFieldEnd()
    if self.macAddress is not None:
      oprot.writeFieldBegin('macAddress', TType.STRING, 2)
      oprot.writeString(self.macAddress)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndoorLocationInfo:
  """
  Indoor location
  (1) mapId - ID of the indoor map on which this location is present
  (2) x - x coordinate on the map
  (3) y - y coordinate on the map
  (4) timestamp - timestamp of this location, in DDMMYYYYhhmmss format

  Attributes:
   - mapId
   - x
   - y
   - timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'mapId', None, None, ), # 1
    (2, TType.STRING, 'x', None, None, ), # 2
    (3, TType.STRING, 'y', None, None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
  )

  def __init__(self, mapId=None, x=None, y=None, timestamp=None,):
    self.mapId = mapId
    self.x = x
    self.y = y
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.mapId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.x = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.y = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndoorLocationInfo')
    if self.mapId is not None:
      oprot.writeFieldBegin('mapId', TType.STRING, 1)
      oprot.writeString(self.mapId)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.STRING, 2)
      oprot.writeString(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.STRING, 3)
      oprot.writeString(self.y)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndoorMapInfo:
  """
  Indoor map information
  (1) mapId - ID of the indoor map
  (2) map - Map file content (binary data)

  Attributes:
   - mapId
   - mapBlob
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'mapId', None, None, ), # 1
    (2, TType.STRING, 'mapBlob', None, None, ), # 2
  )

  def __init__(self, mapId=None, mapBlob=None,):
    self.mapId = mapId
    self.mapBlob = mapBlob

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.mapId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mapBlob = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndoorMapInfo')
    if self.mapId is not None:
      oprot.writeFieldBegin('mapId', TType.STRING, 1)
      oprot.writeString(self.mapId)
      oprot.writeFieldEnd()
    if self.mapBlob is not None:
      oprot.writeFieldBegin('mapBlob', TType.STRING, 2)
      oprot.writeString(self.mapBlob)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
