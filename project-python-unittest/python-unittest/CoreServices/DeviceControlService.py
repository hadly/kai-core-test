#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  DeviceControlService - this service provides API for interactive control of devices
  """
  def getDeviceStatus(self, deviceId):
    """
    Gets a device's current status.

    (1) deviceId - ID of the device.

    Returns the device's status:
    "online" if the device is currently connected and able to communicate with the backend (Core Engine/RMS+).
    "offline" if the device is not connected to the backend.
    "error" if the device is connected but in an error state.
    "incorrect-password" if the backend is able to connect to the device, but not log in due to invalid login credentials.

    Parameters:
     - deviceId
    """
    pass

  def getGPIO(self, deviceId, ioNumber):
    """
    Gets the current status of an I/O pin. This is applicable only to devices which
    have ON/OFF type I/O pins.

    (1) deviceId - ID of the device.
    (2) ioNumber - The digital I/O number of the device, starting with 0.

    Returns the result of the operation.
    "on" if the pin status is ON or HIGH
    "off" if the pin status is OFF or LOW
    "error" on failure to read pin status. There could be several reasons of failure e.g. device is offline or device doesn't
    have the specified I/O control.

    Parameters:
     - deviceId
     - ioNumber
    """
    pass

  def setGPIO(self, deviceId, ioNumber, value):
    """
    Sets an I/O control pin ON or OFF. This is applicable only to devices which
    have ON/OFF type digital I/O control pins.

    (1) deviceId - ID of the device.
    (2) ioNumber - The digital I/O port identifier.
    (3) value - The new value to set - "on" means ON/HIGH; "off" means OFF/LOW.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have the specified I/O control.

    Parameters:
     - deviceId
     - ioNumber
     - value
    """
    pass

  def startPanDevice(self, deviceId, channelId, direction):
    """
    Starts to pan a PTZ device in the specified direction.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.
    (3) direction - The direction of panning: "left" or "right".

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Pan feature.

    Parameters:
     - deviceId
     - channelId
     - direction
    """
    pass

  def stopPanDevice(self, deviceId, channelId):
    """
    Stops panning of a PTZ device.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Pan feature.

    Parameters:
     - deviceId
     - channelId
    """
    pass

  def startTiltDevice(self, deviceId, channelId, direction):
    """
    Starts to tilt a PTZ device in the specified direction.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.
    (3) direction - The direction of panning: "left" or "right".

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Tilt feature.

    Parameters:
     - deviceId
     - channelId
     - direction
    """
    pass

  def stopTiltDevice(self, deviceId, channelId):
    """
    Stops tilting of a PTZ device.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Tilt feature.

    Parameters:
     - deviceId
     - channelId
    """
    pass

  def startZoomDevice(self, deviceId, channelId, direction):
    """
    Starts to zoom a PTZ device in the specified direction.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.
    (3) direction - The direction of panning: "in" or "out".

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Zoom feature.

    Parameters:
     - deviceId
     - channelId
     - direction
    """
    pass

  def stopZoomDevice(self, deviceId, channelId):
    """
    Stops zooming of a PTZ device.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Zoom feature.

    Parameters:
     - deviceId
     - channelId
    """
    pass

  def writeData(self, deviceId, portNumber, data):
    """
    Writes data to a data port of the specified device.

    (1) deviceId - ID of the device.
    (2) portNumber - The data port number.
    (3) data - The data to be written out.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have the specified I/O control.

    Parameters:
     - deviceId
     - portNumber
     - data
    """
    pass

  def readData(self, deviceId, portNumber):
    """
    Reads data from a data port of the specified device.

    (1) deviceId - ID of the device.
    (2) portNumber - The data port number.

    Returns the data read from the device's data port.

    Parameters:
     - deviceId
     - portNumber
    """
    pass


class Client(Iface):
  """
  DeviceControlService - this service provides API for interactive control of devices
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getDeviceStatus(self, deviceId):
    """
    Gets a device's current status.

    (1) deviceId - ID of the device.

    Returns the device's status:
    "online" if the device is currently connected and able to communicate with the backend (Core Engine/RMS+).
    "offline" if the device is not connected to the backend.
    "error" if the device is connected but in an error state.
    "incorrect-password" if the backend is able to connect to the device, but not log in due to invalid login credentials.

    Parameters:
     - deviceId
    """
    self.send_getDeviceStatus(deviceId)
    return self.recv_getDeviceStatus()

  def send_getDeviceStatus(self, deviceId):
    self._oprot.writeMessageBegin('getDeviceStatus', TMessageType.CALL, self._seqid)
    args = getDeviceStatus_args()
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDeviceStatus(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDeviceStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDeviceStatus failed: unknown result");

  def getGPIO(self, deviceId, ioNumber):
    """
    Gets the current status of an I/O pin. This is applicable only to devices which
    have ON/OFF type I/O pins.

    (1) deviceId - ID of the device.
    (2) ioNumber - The digital I/O number of the device, starting with 0.

    Returns the result of the operation.
    "on" if the pin status is ON or HIGH
    "off" if the pin status is OFF or LOW
    "error" on failure to read pin status. There could be several reasons of failure e.g. device is offline or device doesn't
    have the specified I/O control.

    Parameters:
     - deviceId
     - ioNumber
    """
    self.send_getGPIO(deviceId, ioNumber)
    return self.recv_getGPIO()

  def send_getGPIO(self, deviceId, ioNumber):
    self._oprot.writeMessageBegin('getGPIO', TMessageType.CALL, self._seqid)
    args = getGPIO_args()
    args.deviceId = deviceId
    args.ioNumber = ioNumber
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGPIO(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGPIO_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGPIO failed: unknown result");

  def setGPIO(self, deviceId, ioNumber, value):
    """
    Sets an I/O control pin ON or OFF. This is applicable only to devices which
    have ON/OFF type digital I/O control pins.

    (1) deviceId - ID of the device.
    (2) ioNumber - The digital I/O port identifier.
    (3) value - The new value to set - "on" means ON/HIGH; "off" means OFF/LOW.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have the specified I/O control.

    Parameters:
     - deviceId
     - ioNumber
     - value
    """
    self.send_setGPIO(deviceId, ioNumber, value)
    return self.recv_setGPIO()

  def send_setGPIO(self, deviceId, ioNumber, value):
    self._oprot.writeMessageBegin('setGPIO', TMessageType.CALL, self._seqid)
    args = setGPIO_args()
    args.deviceId = deviceId
    args.ioNumber = ioNumber
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setGPIO(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setGPIO_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setGPIO failed: unknown result");

  def startPanDevice(self, deviceId, channelId, direction):
    """
    Starts to pan a PTZ device in the specified direction.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.
    (3) direction - The direction of panning: "left" or "right".

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Pan feature.

    Parameters:
     - deviceId
     - channelId
     - direction
    """
    self.send_startPanDevice(deviceId, channelId, direction)
    return self.recv_startPanDevice()

  def send_startPanDevice(self, deviceId, channelId, direction):
    self._oprot.writeMessageBegin('startPanDevice', TMessageType.CALL, self._seqid)
    args = startPanDevice_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startPanDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startPanDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startPanDevice failed: unknown result");

  def stopPanDevice(self, deviceId, channelId):
    """
    Stops panning of a PTZ device.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Pan feature.

    Parameters:
     - deviceId
     - channelId
    """
    self.send_stopPanDevice(deviceId, channelId)
    return self.recv_stopPanDevice()

  def send_stopPanDevice(self, deviceId, channelId):
    self._oprot.writeMessageBegin('stopPanDevice', TMessageType.CALL, self._seqid)
    args = stopPanDevice_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopPanDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopPanDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stopPanDevice failed: unknown result");

  def startTiltDevice(self, deviceId, channelId, direction):
    """
    Starts to tilt a PTZ device in the specified direction.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.
    (3) direction - The direction of panning: "left" or "right".

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Tilt feature.

    Parameters:
     - deviceId
     - channelId
     - direction
    """
    self.send_startTiltDevice(deviceId, channelId, direction)
    return self.recv_startTiltDevice()

  def send_startTiltDevice(self, deviceId, channelId, direction):
    self._oprot.writeMessageBegin('startTiltDevice', TMessageType.CALL, self._seqid)
    args = startTiltDevice_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startTiltDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startTiltDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startTiltDevice failed: unknown result");

  def stopTiltDevice(self, deviceId, channelId):
    """
    Stops tilting of a PTZ device.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Tilt feature.

    Parameters:
     - deviceId
     - channelId
    """
    self.send_stopTiltDevice(deviceId, channelId)
    return self.recv_stopTiltDevice()

  def send_stopTiltDevice(self, deviceId, channelId):
    self._oprot.writeMessageBegin('stopTiltDevice', TMessageType.CALL, self._seqid)
    args = stopTiltDevice_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopTiltDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopTiltDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stopTiltDevice failed: unknown result");

  def startZoomDevice(self, deviceId, channelId, direction):
    """
    Starts to zoom a PTZ device in the specified direction.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.
    (3) direction - The direction of panning: "in" or "out".

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Zoom feature.

    Parameters:
     - deviceId
     - channelId
     - direction
    """
    self.send_startZoomDevice(deviceId, channelId, direction)
    return self.recv_startZoomDevice()

  def send_startZoomDevice(self, deviceId, channelId, direction):
    self._oprot.writeMessageBegin('startZoomDevice', TMessageType.CALL, self._seqid)
    args = startZoomDevice_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.direction = direction
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startZoomDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startZoomDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startZoomDevice failed: unknown result");

  def stopZoomDevice(self, deviceId, channelId):
    """
    Stops zooming of a PTZ device.

    (1) deviceId - ID of the device.
    (2) channelId - channel of the device.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have Zoom feature.

    Parameters:
     - deviceId
     - channelId
    """
    self.send_stopZoomDevice(deviceId, channelId)
    return self.recv_stopZoomDevice()

  def send_stopZoomDevice(self, deviceId, channelId):
    self._oprot.writeMessageBegin('stopZoomDevice', TMessageType.CALL, self._seqid)
    args = stopZoomDevice_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopZoomDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopZoomDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stopZoomDevice failed: unknown result");

  def writeData(self, deviceId, portNumber, data):
    """
    Writes data to a data port of the specified device.

    (1) deviceId - ID of the device.
    (2) portNumber - The data port number.
    (3) data - The data to be written out.

    Returns the result of the operation.
    "ok" on successful completion of the operation.
    "error" on failure. There could be several reasons of failure e.g. device is offline or device doesn't
    have the specified I/O control.

    Parameters:
     - deviceId
     - portNumber
     - data
    """
    self.send_writeData(deviceId, portNumber, data)
    return self.recv_writeData()

  def send_writeData(self, deviceId, portNumber, data):
    self._oprot.writeMessageBegin('writeData', TMessageType.CALL, self._seqid)
    args = writeData_args()
    args.deviceId = deviceId
    args.portNumber = portNumber
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_writeData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = writeData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "writeData failed: unknown result");

  def readData(self, deviceId, portNumber):
    """
    Reads data from a data port of the specified device.

    (1) deviceId - ID of the device.
    (2) portNumber - The data port number.

    Returns the data read from the device's data port.

    Parameters:
     - deviceId
     - portNumber
    """
    self.send_readData(deviceId, portNumber)
    return self.recv_readData()

  def send_readData(self, deviceId, portNumber):
    self._oprot.writeMessageBegin('readData', TMessageType.CALL, self._seqid)
    args = readData_args()
    args.deviceId = deviceId
    args.portNumber = portNumber
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_readData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = readData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "readData failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getDeviceStatus"] = Processor.process_getDeviceStatus
    self._processMap["getGPIO"] = Processor.process_getGPIO
    self._processMap["setGPIO"] = Processor.process_setGPIO
    self._processMap["startPanDevice"] = Processor.process_startPanDevice
    self._processMap["stopPanDevice"] = Processor.process_stopPanDevice
    self._processMap["startTiltDevice"] = Processor.process_startTiltDevice
    self._processMap["stopTiltDevice"] = Processor.process_stopTiltDevice
    self._processMap["startZoomDevice"] = Processor.process_startZoomDevice
    self._processMap["stopZoomDevice"] = Processor.process_stopZoomDevice
    self._processMap["writeData"] = Processor.process_writeData
    self._processMap["readData"] = Processor.process_readData

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getDeviceStatus(self, seqid, iprot, oprot):
    args = getDeviceStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDeviceStatus_result()
    try:
      result.success = self._handler.getDeviceStatus(args.deviceId)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("getDeviceStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGPIO(self, seqid, iprot, oprot):
    args = getGPIO_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGPIO_result()
    try:
      result.success = self._handler.getGPIO(args.deviceId, args.ioNumber)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("getGPIO", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setGPIO(self, seqid, iprot, oprot):
    args = setGPIO_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setGPIO_result()
    try:
      result.success = self._handler.setGPIO(args.deviceId, args.ioNumber, args.value)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("setGPIO", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startPanDevice(self, seqid, iprot, oprot):
    args = startPanDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startPanDevice_result()
    try:
      result.success = self._handler.startPanDevice(args.deviceId, args.channelId, args.direction)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("startPanDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopPanDevice(self, seqid, iprot, oprot):
    args = stopPanDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopPanDevice_result()
    try:
      result.success = self._handler.stopPanDevice(args.deviceId, args.channelId)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("stopPanDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startTiltDevice(self, seqid, iprot, oprot):
    args = startTiltDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startTiltDevice_result()
    try:
      result.success = self._handler.startTiltDevice(args.deviceId, args.channelId, args.direction)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("startTiltDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopTiltDevice(self, seqid, iprot, oprot):
    args = stopTiltDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopTiltDevice_result()
    try:
      result.success = self._handler.stopTiltDevice(args.deviceId, args.channelId)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("stopTiltDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startZoomDevice(self, seqid, iprot, oprot):
    args = startZoomDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startZoomDevice_result()
    try:
      result.success = self._handler.startZoomDevice(args.deviceId, args.channelId, args.direction)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("startZoomDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopZoomDevice(self, seqid, iprot, oprot):
    args = stopZoomDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopZoomDevice_result()
    try:
      result.success = self._handler.stopZoomDevice(args.deviceId, args.channelId)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("stopZoomDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_writeData(self, seqid, iprot, oprot):
    args = writeData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = writeData_result()
    try:
      result.success = self._handler.writeData(args.deviceId, args.portNumber, args.data)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("writeData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_readData(self, seqid, iprot, oprot):
    args = readData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = readData_result()
    try:
      result.success = self._handler.readData(args.deviceId, args.portNumber)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("readData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getDeviceStatus_args:
  """
  Attributes:
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
  )

  def __init__(self, deviceId=None,):
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeviceStatus_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDeviceStatus_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDeviceStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGPIO_args:
  """
  Attributes:
   - deviceId
   - ioNumber
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'ioNumber', None, None, ), # 2
  )

  def __init__(self, deviceId=None, ioNumber=None,):
    self.deviceId = deviceId
    self.ioNumber = ioNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ioNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGPIO_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.ioNumber is not None:
      oprot.writeFieldBegin('ioNumber', TType.STRING, 2)
      oprot.writeString(self.ioNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGPIO_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGPIO_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGPIO_args:
  """
  Attributes:
   - deviceId
   - ioNumber
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'ioNumber', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
  )

  def __init__(self, deviceId=None, ioNumber=None, value=None,):
    self.deviceId = deviceId
    self.ioNumber = ioNumber
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ioNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGPIO_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.ioNumber is not None:
      oprot.writeFieldBegin('ioNumber', TType.STRING, 2)
      oprot.writeString(self.ioNumber)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGPIO_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGPIO_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startPanDevice_args:
  """
  Attributes:
   - deviceId
   - channelId
   - direction
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.STRING, 'direction', None, None, ), # 3
  )

  def __init__(self, deviceId=None, channelId=None, direction=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.direction = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startPanDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.STRING, 3)
      oprot.writeString(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startPanDevice_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startPanDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopPanDevice_args:
  """
  Attributes:
   - deviceId
   - channelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
  )

  def __init__(self, deviceId=None, channelId=None,):
    self.deviceId = deviceId
    self.channelId = channelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopPanDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopPanDevice_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopPanDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startTiltDevice_args:
  """
  Attributes:
   - deviceId
   - channelId
   - direction
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.STRING, 'direction', None, None, ), # 3
  )

  def __init__(self, deviceId=None, channelId=None, direction=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.direction = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startTiltDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.STRING, 3)
      oprot.writeString(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startTiltDevice_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startTiltDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopTiltDevice_args:
  """
  Attributes:
   - deviceId
   - channelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
  )

  def __init__(self, deviceId=None, channelId=None,):
    self.deviceId = deviceId
    self.channelId = channelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopTiltDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopTiltDevice_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopTiltDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startZoomDevice_args:
  """
  Attributes:
   - deviceId
   - channelId
   - direction
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.STRING, 'direction', None, None, ), # 3
  )

  def __init__(self, deviceId=None, channelId=None, direction=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.direction = direction

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.direction = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startZoomDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.direction is not None:
      oprot.writeFieldBegin('direction', TType.STRING, 3)
      oprot.writeString(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startZoomDevice_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startZoomDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopZoomDevice_args:
  """
  Attributes:
   - deviceId
   - channelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
  )

  def __init__(self, deviceId=None, channelId=None,):
    self.deviceId = deviceId
    self.channelId = channelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopZoomDevice_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopZoomDevice_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopZoomDevice_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class writeData_args:
  """
  Attributes:
   - deviceId
   - portNumber
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'portNumber', None, None, ), # 2
    (3, TType.LIST, 'data', (TType.BYTE,None), None, ), # 3
  )

  def __init__(self, deviceId=None, portNumber=None, data=None,):
    self.deviceId = deviceId
    self.portNumber = portNumber
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.portNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.data = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = iprot.readByte();
            self.data.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('writeData_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.portNumber is not None:
      oprot.writeFieldBegin('portNumber', TType.STRING, 2)
      oprot.writeString(self.portNumber)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.LIST, 3)
      oprot.writeListBegin(TType.BYTE, len(self.data))
      for iter90 in self.data:
        oprot.writeByte(iter90)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class writeData_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('writeData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readData_args:
  """
  Attributes:
   - deviceId
   - portNumber
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'portNumber', None, None, ), # 2
  )

  def __init__(self, deviceId=None, portNumber=None,):
    self.deviceId = deviceId
    self.portNumber = portNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.portNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readData_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.portNumber is not None:
      oprot.writeFieldBegin('portNumber', TType.STRING, 2)
      oprot.writeString(self.portNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readData_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE,None), None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = iprot.readByte();
            self.success.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.BYTE, len(self.success))
      for iter97 in self.success:
        oprot.writeByte(iter97)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
