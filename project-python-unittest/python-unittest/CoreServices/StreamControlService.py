#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  StreamControlService - this service provides interface for
  management (control) of a streaming sessions. Platform uses
  this interface to begin/end streaming.
  NOTE 1: This is only for control, not for actual video data transfer.
  """
  def beginStreamSession(self, sessionId, ttl, type, allowedClientIpAddresses, deviceId, channelId, startTimestamp, endTimeStamp):
    """
    Begin a new media session. This is a request from Platform to Core
    Engine. On success, Core Engine should return the dynamically generated
    URL of stream.

    (1) sessionId - A handle for this session for future reference.
    (2) ttl - UTC time stamp when this session becomes invalid, unless
              renewed by keepStreamSessionAlive() defined below.
    (3) type - the type of stream requested by client. Valid values are:
                "http/mjpeg" for M-JPEG video over HTTP protocol
                "http/h264" for H.264 video over HTTP protocol
                "rtsp/h264" for H.264 video over RTSP protocol
                "http/jpeg" for JPEG snapshots over HTTP protocol
    (4) allowedClientIpAddresses - list of IP address from which the Core
         may accept connections for streaming of this URL.
    (5) deviceId - Unique ID of the device whose stream is requested.
    (6) channelId - The requested Channel number.
    (7) startTimestamp - start date/time from where the stream should begin,
         or empty string "" if LIVE stream is requested (ddMMyyyyHHmmss format).
    (8) endTimestamp - end date/time of the stream, or empty string ""
         if LIVE stream is requested (ddMMyyyyHHmmss format).

    RETURN value is a list of the dynamically generated URLs. It is the playlist that contains
    all required streams, to be played in that order. For example, if backend recording system
    records 15 minutes of stream to a file, and the requested duration is of 1 hour, the playlist
    should ideally contain 4 stream URLs, to be played in order. Each with 15 minutes of video.
    This allows for efficient stream management, and also makes seeking easier.

    Parameters:
     - sessionId
     - ttl
     - type
     - allowedClientIpAddresses
     - deviceId
     - channelId
     - startTimestamp
     - endTimeStamp
    """
    pass

  def keepStreamSessionAlive(self, sessionId, ttl, allowedClientIpAddresses):
    """
    Renew an existing session. UP will use this API to update session keys
    which are about to expire and to inform RS about change of client IP
    address.
    (1) sessionId - A handle for this session for future reference.
    (2) ttl - UTC time stamp when this session becomes invalid, unless
                 renewed again
    (3) allowedClientIpAddresses - Updated list of allowed client IP
                 addresses. If any connections exist from IP addresses not
                 in this list, they should be terminated.

    Parameters:
     - sessionId
     - ttl
     - allowedClientIpAddresses
    """
    pass

  def endStreamSession(self, sessionId):
    """
    Mark the end of a stream session.

    Terminate all existing connections from clients for this session's URL,
    and destroy session information.
    (1) sessionId - Server ID.

    Parameters:
     - sessionId
    """
    pass

  def getActiveOutboundStreamList(self, ):
    """
    Returns list of active outbound streams.
    """
    pass

  def getRecordedVideoList(self, deviceId, channelId, startTimestamp, endTimeStamp):
    """
    Returns list of available recorded videos.

    Parameters:
     - deviceId
     - channelId
     - startTimestamp
     - endTimeStamp
    """
    pass

  def getStorageStatus(self, ):
    """
    Returns list of recording server storage status.
    """
    pass


class Client(Iface):
  """
  StreamControlService - this service provides interface for
  management (control) of a streaming sessions. Platform uses
  this interface to begin/end streaming.
  NOTE 1: This is only for control, not for actual video data transfer.
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def beginStreamSession(self, sessionId, ttl, type, allowedClientIpAddresses, deviceId, channelId, startTimestamp, endTimeStamp):
    """
    Begin a new media session. This is a request from Platform to Core
    Engine. On success, Core Engine should return the dynamically generated
    URL of stream.

    (1) sessionId - A handle for this session for future reference.
    (2) ttl - UTC time stamp when this session becomes invalid, unless
              renewed by keepStreamSessionAlive() defined below.
    (3) type - the type of stream requested by client. Valid values are:
                "http/mjpeg" for M-JPEG video over HTTP protocol
                "http/h264" for H.264 video over HTTP protocol
                "rtsp/h264" for H.264 video over RTSP protocol
                "http/jpeg" for JPEG snapshots over HTTP protocol
    (4) allowedClientIpAddresses - list of IP address from which the Core
         may accept connections for streaming of this URL.
    (5) deviceId - Unique ID of the device whose stream is requested.
    (6) channelId - The requested Channel number.
    (7) startTimestamp - start date/time from where the stream should begin,
         or empty string "" if LIVE stream is requested (ddMMyyyyHHmmss format).
    (8) endTimestamp - end date/time of the stream, or empty string ""
         if LIVE stream is requested (ddMMyyyyHHmmss format).

    RETURN value is a list of the dynamically generated URLs. It is the playlist that contains
    all required streams, to be played in that order. For example, if backend recording system
    records 15 minutes of stream to a file, and the requested duration is of 1 hour, the playlist
    should ideally contain 4 stream URLs, to be played in order. Each with 15 minutes of video.
    This allows for efficient stream management, and also makes seeking easier.

    Parameters:
     - sessionId
     - ttl
     - type
     - allowedClientIpAddresses
     - deviceId
     - channelId
     - startTimestamp
     - endTimeStamp
    """
    self.send_beginStreamSession(sessionId, ttl, type, allowedClientIpAddresses, deviceId, channelId, startTimestamp, endTimeStamp)
    return self.recv_beginStreamSession()

  def send_beginStreamSession(self, sessionId, ttl, type, allowedClientIpAddresses, deviceId, channelId, startTimestamp, endTimeStamp):
    self._oprot.writeMessageBegin('beginStreamSession', TMessageType.CALL, self._seqid)
    args = beginStreamSession_args()
    args.sessionId = sessionId
    args.ttl = ttl
    args.type = type
    args.allowedClientIpAddresses = allowedClientIpAddresses
    args.deviceId = deviceId
    args.channelId = channelId
    args.startTimestamp = startTimestamp
    args.endTimeStamp = endTimeStamp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_beginStreamSession(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = beginStreamSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "beginStreamSession failed: unknown result");

  def keepStreamSessionAlive(self, sessionId, ttl, allowedClientIpAddresses):
    """
    Renew an existing session. UP will use this API to update session keys
    which are about to expire and to inform RS about change of client IP
    address.
    (1) sessionId - A handle for this session for future reference.
    (2) ttl - UTC time stamp when this session becomes invalid, unless
                 renewed again
    (3) allowedClientIpAddresses - Updated list of allowed client IP
                 addresses. If any connections exist from IP addresses not
                 in this list, they should be terminated.

    Parameters:
     - sessionId
     - ttl
     - allowedClientIpAddresses
    """
    self.send_keepStreamSessionAlive(sessionId, ttl, allowedClientIpAddresses)
    return self.recv_keepStreamSessionAlive()

  def send_keepStreamSessionAlive(self, sessionId, ttl, allowedClientIpAddresses):
    self._oprot.writeMessageBegin('keepStreamSessionAlive', TMessageType.CALL, self._seqid)
    args = keepStreamSessionAlive_args()
    args.sessionId = sessionId
    args.ttl = ttl
    args.allowedClientIpAddresses = allowedClientIpAddresses
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_keepStreamSessionAlive(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = keepStreamSessionAlive_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "keepStreamSessionAlive failed: unknown result");

  def endStreamSession(self, sessionId):
    """
    Mark the end of a stream session.

    Terminate all existing connections from clients for this session's URL,
    and destroy session information.
    (1) sessionId - Server ID.

    Parameters:
     - sessionId
    """
    self.send_endStreamSession(sessionId)
    return self.recv_endStreamSession()

  def send_endStreamSession(self, sessionId):
    self._oprot.writeMessageBegin('endStreamSession', TMessageType.CALL, self._seqid)
    args = endStreamSession_args()
    args.sessionId = sessionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_endStreamSession(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = endStreamSession_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "endStreamSession failed: unknown result");

  def getActiveOutboundStreamList(self, ):
    """
    Returns list of active outbound streams.
    """
    self.send_getActiveOutboundStreamList()
    return self.recv_getActiveOutboundStreamList()

  def send_getActiveOutboundStreamList(self, ):
    self._oprot.writeMessageBegin('getActiveOutboundStreamList', TMessageType.CALL, self._seqid)
    args = getActiveOutboundStreamList_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getActiveOutboundStreamList(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getActiveOutboundStreamList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveOutboundStreamList failed: unknown result");

  def getRecordedVideoList(self, deviceId, channelId, startTimestamp, endTimeStamp):
    """
    Returns list of available recorded videos.

    Parameters:
     - deviceId
     - channelId
     - startTimestamp
     - endTimeStamp
    """
    self.send_getRecordedVideoList(deviceId, channelId, startTimestamp, endTimeStamp)
    return self.recv_getRecordedVideoList()

  def send_getRecordedVideoList(self, deviceId, channelId, startTimestamp, endTimeStamp):
    self._oprot.writeMessageBegin('getRecordedVideoList', TMessageType.CALL, self._seqid)
    args = getRecordedVideoList_args()
    args.deviceId = deviceId
    args.channelId = channelId
    args.startTimestamp = startTimestamp
    args.endTimeStamp = endTimeStamp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecordedVideoList(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecordedVideoList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecordedVideoList failed: unknown result");

  def getStorageStatus(self, ):
    """
    Returns list of recording server storage status.
    """
    self.send_getStorageStatus()
    return self.recv_getStorageStatus()

  def send_getStorageStatus(self, ):
    self._oprot.writeMessageBegin('getStorageStatus', TMessageType.CALL, self._seqid)
    args = getStorageStatus_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getStorageStatus(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getStorageStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.coreExp is not None:
      raise result.coreExp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getStorageStatus failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["beginStreamSession"] = Processor.process_beginStreamSession
    self._processMap["keepStreamSessionAlive"] = Processor.process_keepStreamSessionAlive
    self._processMap["endStreamSession"] = Processor.process_endStreamSession
    self._processMap["getActiveOutboundStreamList"] = Processor.process_getActiveOutboundStreamList
    self._processMap["getRecordedVideoList"] = Processor.process_getRecordedVideoList
    self._processMap["getStorageStatus"] = Processor.process_getStorageStatus

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_beginStreamSession(self, seqid, iprot, oprot):
    args = beginStreamSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = beginStreamSession_result()
    try:
      result.success = self._handler.beginStreamSession(args.sessionId, args.ttl, args.type, args.allowedClientIpAddresses, args.deviceId, args.channelId, args.startTimestamp, args.endTimeStamp)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("beginStreamSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_keepStreamSessionAlive(self, seqid, iprot, oprot):
    args = keepStreamSessionAlive_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = keepStreamSessionAlive_result()
    try:
      result.success = self._handler.keepStreamSessionAlive(args.sessionId, args.ttl, args.allowedClientIpAddresses)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("keepStreamSessionAlive", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_endStreamSession(self, seqid, iprot, oprot):
    args = endStreamSession_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = endStreamSession_result()
    try:
      result.success = self._handler.endStreamSession(args.sessionId)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("endStreamSession", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getActiveOutboundStreamList(self, seqid, iprot, oprot):
    args = getActiveOutboundStreamList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getActiveOutboundStreamList_result()
    try:
      result.success = self._handler.getActiveOutboundStreamList()
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("getActiveOutboundStreamList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecordedVideoList(self, seqid, iprot, oprot):
    args = getRecordedVideoList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecordedVideoList_result()
    try:
      result.success = self._handler.getRecordedVideoList(args.deviceId, args.channelId, args.startTimestamp, args.endTimeStamp)
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("getRecordedVideoList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getStorageStatus(self, seqid, iprot, oprot):
    args = getStorageStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getStorageStatus_result()
    try:
      result.success = self._handler.getStorageStatus()
    except CoreException, coreExp:
      result.coreExp = coreExp
    oprot.writeMessageBegin("getStorageStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class beginStreamSession_args:
  """
  Attributes:
   - sessionId
   - ttl
   - type
   - allowedClientIpAddresses
   - deviceId
   - channelId
   - startTimestamp
   - endTimeStamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionId', None, None, ), # 1
    (2, TType.I64, 'ttl', None, None, ), # 2
    (3, TType.STRING, 'type', None, None, ), # 3
    (4, TType.LIST, 'allowedClientIpAddresses', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'deviceId', None, None, ), # 5
    (6, TType.STRING, 'channelId', None, None, ), # 6
    (7, TType.STRING, 'startTimestamp', None, None, ), # 7
    (8, TType.STRING, 'endTimeStamp', None, None, ), # 8
  )

  def __init__(self, sessionId=None, ttl=None, type=None, allowedClientIpAddresses=None, deviceId=None, channelId=None, startTimestamp=None, endTimeStamp=None,):
    self.sessionId = sessionId
    self.ttl = ttl
    self.type = type
    self.allowedClientIpAddresses = allowedClientIpAddresses
    self.deviceId = deviceId
    self.channelId = channelId
    self.startTimestamp = startTimestamp
    self.endTimeStamp = endTimeStamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ttl = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.allowedClientIpAddresses = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.allowedClientIpAddresses.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.startTimestamp = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.endTimeStamp = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('beginStreamSession_args')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 1)
      oprot.writeString(self.sessionId)
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I64, 2)
      oprot.writeI64(self.ttl)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 3)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.allowedClientIpAddresses is not None:
      oprot.writeFieldBegin('allowedClientIpAddresses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.allowedClientIpAddresses))
      for iter13 in self.allowedClientIpAddresses:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 5)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 6)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.startTimestamp is not None:
      oprot.writeFieldBegin('startTimestamp', TType.STRING, 7)
      oprot.writeString(self.startTimestamp)
      oprot.writeFieldEnd()
    if self.endTimeStamp is not None:
      oprot.writeFieldBegin('endTimeStamp', TType.STRING, 8)
      oprot.writeString(self.endTimeStamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class beginStreamSession_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('beginStreamSession_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter20 in self.success:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class keepStreamSessionAlive_args:
  """
  Attributes:
   - sessionId
   - ttl
   - allowedClientIpAddresses
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionId', None, None, ), # 1
    (2, TType.I64, 'ttl', None, None, ), # 2
    (3, TType.LIST, 'allowedClientIpAddresses', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, sessionId=None, ttl=None, allowedClientIpAddresses=None,):
    self.sessionId = sessionId
    self.ttl = ttl
    self.allowedClientIpAddresses = allowedClientIpAddresses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ttl = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.allowedClientIpAddresses = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString();
            self.allowedClientIpAddresses.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('keepStreamSessionAlive_args')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 1)
      oprot.writeString(self.sessionId)
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I64, 2)
      oprot.writeI64(self.ttl)
      oprot.writeFieldEnd()
    if self.allowedClientIpAddresses is not None:
      oprot.writeFieldBegin('allowedClientIpAddresses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.allowedClientIpAddresses))
      for iter27 in self.allowedClientIpAddresses:
        oprot.writeString(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class keepStreamSessionAlive_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('keepStreamSessionAlive_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class endStreamSession_args:
  """
  Attributes:
   - sessionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionId', None, None, ), # 1
  )

  def __init__(self, sessionId=None,):
    self.sessionId = sessionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('endStreamSession_args')
    if self.sessionId is not None:
      oprot.writeFieldBegin('sessionId', TType.STRING, 1)
      oprot.writeString(self.sessionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class endStreamSession_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('endStreamSession_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getActiveOutboundStreamList_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getActiveOutboundStreamList_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getActiveOutboundStreamList_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(StreamInfo, StreamInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = StreamInfo()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getActiveOutboundStreamList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordedVideoList_args:
  """
  Attributes:
   - deviceId
   - channelId
   - startTimestamp
   - endTimeStamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.STRING, 'startTimestamp', None, None, ), # 3
    (4, TType.STRING, 'endTimeStamp', None, None, ), # 4
  )

  def __init__(self, deviceId=None, channelId=None, startTimestamp=None, endTimeStamp=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.startTimestamp = startTimestamp
    self.endTimeStamp = endTimeStamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startTimestamp = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endTimeStamp = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordedVideoList_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.startTimestamp is not None:
      oprot.writeFieldBegin('startTimestamp', TType.STRING, 3)
      oprot.writeString(self.startTimestamp)
      oprot.writeFieldEnd()
    if self.endTimeStamp is not None:
      oprot.writeFieldBegin('endTimeStamp', TType.STRING, 4)
      oprot.writeString(self.endTimeStamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordedVideoList_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(RecordedVideoInfo, RecordedVideoInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = RecordedVideoInfo()
            _elem40.read(iprot)
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordedVideoList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter41 in self.success:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStorageStatus_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStorageStatus_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStorageStatus_result:
  """
  Attributes:
   - success
   - coreExp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(StorageInfo, StorageInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'coreExp', (CoreException, CoreException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, coreExp=None,):
    self.success = success
    self.coreExp = coreExp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = StorageInfo()
            _elem47.read(iprot)
            self.success.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.coreExp = CoreException()
          self.coreExp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStorageStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter48 in self.success:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.coreExp is not None:
      oprot.writeFieldBegin('coreExp', TType.STRUCT, 1)
      self.coreExp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
