#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class NodeOperation:
  NO_OPERATION = 0
  START_VIDEO_UPSTREAM = 16
  STOP_VIDEO_UPSTREAM = 17
  START_SNAPSHOT_UPSTREAM = 32
  STOP_SNAPSHOT_UPSTREAM = 33
  START_STREAM_UPSTREAM = 48
  STOP_STREAM_UPSTREAM = 49

  _VALUES_TO_NAMES = {
    0: "NO_OPERATION",
    16: "START_VIDEO_UPSTREAM",
    17: "STOP_VIDEO_UPSTREAM",
    32: "START_SNAPSHOT_UPSTREAM",
    33: "STOP_SNAPSHOT_UPSTREAM",
    48: "START_STREAM_UPSTREAM",
    49: "STOP_STREAM_UPSTREAM",
  }

  _NAMES_TO_VALUES = {
    "NO_OPERATION": 0,
    "START_VIDEO_UPSTREAM": 16,
    "STOP_VIDEO_UPSTREAM": 17,
    "START_SNAPSHOT_UPSTREAM": 32,
    "STOP_SNAPSHOT_UPSTREAM": 33,
    "START_STREAM_UPSTREAM": 48,
    "STOP_STREAM_UPSTREAM": 49,
  }


class DeviceStatus:
  """
  Device Information
  (1) deviceId - device id
  (2) frameRate - frame rate of sub stream
  (3) kupChannelId - corresponding channel id of this device id on KUP

  Attributes:
   - deviceId
   - frameRate
   - kupChannelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.DOUBLE, 'frameRate', None, None, ), # 2
    (3, TType.I32, 'kupChannelId', None, None, ), # 3
  )

  def __init__(self, deviceId=None, frameRate=None, kupChannelId=None,):
    self.deviceId = deviceId
    self.frameRate = frameRate
    self.kupChannelId = kupChannelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.frameRate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.kupChannelId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeviceStatus')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.frameRate is not None:
      oprot.writeFieldBegin('frameRate', TType.DOUBLE, 2)
      oprot.writeDouble(self.frameRate)
      oprot.writeFieldEnd()
    if self.kupChannelId is not None:
      oprot.writeFieldBegin('kupChannelId', TType.I32, 3)
      oprot.writeI32(self.kupChannelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NodeStatus:
  """
  Node Information
  (1) createdTime - the UTC timestamp when node service started
  (2) deviceAdded - the number of devices successfully added
  (3) deviceFailed - the number of devices failed to add
  (4) nodeMacAddress - MAC address of node
  (5) nodeIpAddress - IP address of node
  (6) kupHost - cloud arbiter hostname of node
  (7) kupIpAddress - cloud arbiter IP address of node
  (8) cpuUsage - cpu usage of node [0.00-100.00]
  (9) memoryUsage - memory usage of node [0.00-100.00]
  (10) diskUsage - disk usage of node [0.00-100.00]
  (11) status - detailed device status in this node, ordered by deviceId
  (12) statusData - json formatted extra information of status

  Attributes:
   - createdTime
   - deviceAdded
   - deviceFailed
   - nodeMacAddress
   - nodeIpAddress
   - kupHost
   - kupIpAddress
   - cpuUsage
   - memoryUsage
   - diskUsage
   - status
   - statusData
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'createdTime', None, None, ), # 1
    (2, TType.I32, 'deviceAdded', None, None, ), # 2
    (3, TType.I32, 'deviceFailed', None, None, ), # 3
    (4, TType.STRING, 'nodeMacAddress', None, None, ), # 4
    (5, TType.STRING, 'nodeIpAddress', None, None, ), # 5
    (6, TType.STRING, 'kupHost', None, None, ), # 6
    (7, TType.STRING, 'kupIpAddress', None, None, ), # 7
    (8, TType.DOUBLE, 'cpuUsage', None, None, ), # 8
    (9, TType.DOUBLE, 'memoryUsage', None, None, ), # 9
    (10, TType.DOUBLE, 'diskUsage', None, None, ), # 10
    (11, TType.LIST, 'status', (TType.STRUCT,(DeviceStatus, DeviceStatus.thrift_spec)), None, ), # 11
    (12, TType.STRING, 'statusData', None, None, ), # 12
  )

  def __init__(self, createdTime=None, deviceAdded=None, deviceFailed=None, nodeMacAddress=None, nodeIpAddress=None, kupHost=None, kupIpAddress=None, cpuUsage=None, memoryUsage=None, diskUsage=None, status=None, statusData=None,):
    self.createdTime = createdTime
    self.deviceAdded = deviceAdded
    self.deviceFailed = deviceFailed
    self.nodeMacAddress = nodeMacAddress
    self.nodeIpAddress = nodeIpAddress
    self.kupHost = kupHost
    self.kupIpAddress = kupIpAddress
    self.cpuUsage = cpuUsage
    self.memoryUsage = memoryUsage
    self.diskUsage = diskUsage
    self.status = status
    self.statusData = statusData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.createdTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.deviceAdded = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.deviceFailed = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.nodeMacAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.nodeIpAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.kupHost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.kupIpAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.cpuUsage = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.DOUBLE:
          self.memoryUsage = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.DOUBLE:
          self.diskUsage = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.status = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = DeviceStatus()
            _elem5.read(iprot)
            self.status.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.statusData = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NodeStatus')
    if self.createdTime is not None:
      oprot.writeFieldBegin('createdTime', TType.I64, 1)
      oprot.writeI64(self.createdTime)
      oprot.writeFieldEnd()
    if self.deviceAdded is not None:
      oprot.writeFieldBegin('deviceAdded', TType.I32, 2)
      oprot.writeI32(self.deviceAdded)
      oprot.writeFieldEnd()
    if self.deviceFailed is not None:
      oprot.writeFieldBegin('deviceFailed', TType.I32, 3)
      oprot.writeI32(self.deviceFailed)
      oprot.writeFieldEnd()
    if self.nodeMacAddress is not None:
      oprot.writeFieldBegin('nodeMacAddress', TType.STRING, 4)
      oprot.writeString(self.nodeMacAddress)
      oprot.writeFieldEnd()
    if self.nodeIpAddress is not None:
      oprot.writeFieldBegin('nodeIpAddress', TType.STRING, 5)
      oprot.writeString(self.nodeIpAddress)
      oprot.writeFieldEnd()
    if self.kupHost is not None:
      oprot.writeFieldBegin('kupHost', TType.STRING, 6)
      oprot.writeString(self.kupHost)
      oprot.writeFieldEnd()
    if self.kupIpAddress is not None:
      oprot.writeFieldBegin('kupIpAddress', TType.STRING, 7)
      oprot.writeString(self.kupIpAddress)
      oprot.writeFieldEnd()
    if self.cpuUsage is not None:
      oprot.writeFieldBegin('cpuUsage', TType.DOUBLE, 8)
      oprot.writeDouble(self.cpuUsage)
      oprot.writeFieldEnd()
    if self.memoryUsage is not None:
      oprot.writeFieldBegin('memoryUsage', TType.DOUBLE, 9)
      oprot.writeDouble(self.memoryUsage)
      oprot.writeFieldEnd()
    if self.diskUsage is not None:
      oprot.writeFieldBegin('diskUsage', TType.DOUBLE, 10)
      oprot.writeDouble(self.diskUsage)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.LIST, 11)
      oprot.writeListBegin(TType.STRUCT, len(self.status))
      for iter6 in self.status:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.statusData is not None:
      oprot.writeFieldBegin('statusData', TType.STRING, 12)
      oprot.writeString(self.statusData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommandInfo:
  """
  Command Information
  (1) command - command type
  (2) channelMask - binary mask for channels
  (3) commandData - json formatted extra information of command

  Attributes:
   - command
   - channelMask
   - commandData
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'command', None, None, ), # 1
    (2, TType.I32, 'channelMask', None, None, ), # 2
    (3, TType.STRING, 'commandData', None, None, ), # 3
  )

  def __init__(self, command=None, channelMask=None, commandData=None,):
    self.command = command
    self.channelMask = channelMask
    self.commandData = commandData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.command = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channelMask = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.commandData = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommandInfo')
    if self.command is not None:
      oprot.writeFieldBegin('command', TType.I32, 1)
      oprot.writeI32(self.command)
      oprot.writeFieldEnd()
    if self.channelMask is not None:
      oprot.writeFieldBegin('channelMask', TType.I32, 2)
      oprot.writeI32(self.channelMask)
      oprot.writeFieldEnd()
    if self.commandData is not None:
      oprot.writeFieldBegin('commandData', TType.STRING, 3)
      oprot.writeString(self.commandData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
